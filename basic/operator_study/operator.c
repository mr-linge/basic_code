#include <stdio.h>
#include <stdint.h>

/*
   位运算
   位运算的运算分量只能是整型或字符型数据，位运算把运算对象看作是由二进位组成的位串信息，按位完成指定的运算，得到位串信息的结果。
   位运算符有：
   &(按位与)、|(按位或)、^(按位异或)、~ (按位取反)。
   其中，按位取反运算符是单目运算符，其余均为双目运算符。
   位运算符的优先级从高到低，依次为~、&、^、|，
   其中~的结合方向自右至左，且优先级高于算术运算符，其余运算符的结合方向都是自左至右，且优先级低于关系运算符。
   (1)按位与运算符(&)
   按位与运算将两个运算分量的对应位按位遵照以下规则进行计算：
   0 & 0 = 0, 0 & 1 = 0, 1 & 0 = 0, 1 & 1 = 1。
   即同为 1 的位，结果为 1，否则结果为 0。
   例如，设3的内部表示为
   00000011
   5的内部表示为
   00000101
   则3&5的结果为
   00000001
   按位与运算有两种典型用法，一是取一个位串信息的某几位，如以下代码截取x的最低7位：x & 0177。二是让某变量保留某几位，其余位置0，如以下代码让x只保留最低6位：x = x & 077。以上用法都先要设计好一个常数，该常数只有需要的位是1，不需要的位是0。用它与指定的位串信息按位与。
   (2)按位或运算符(|)
   按位或运算将两个运算分量的对应位按位遵照以下规则进行计算：
   0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1
   即只要有1个是1的位，结果为1，否则为0。
   例如，023 | 035 结果为037。
   按位或运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成：
   j = 017|j
   (3)按位异或运算符(^)
   按位异或运算将两个运算分量的对应位按位遵照以下规则进行计算：
   0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0
   即相应位的值相同的，结果为 0，不相同的结果为 1。
   例如，013^035结果为026。
   异或运算的意思是求两个运算分量相应位值是否相异，相异的为1，相同的为0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。如欲求整型变量j的最右4位信息的反，用逻辑异或运算017^j，就能求得j最右4位的信息的反,即原来为1的位，结果是0,原来为0的位，结果是1。
   (4)按位取反运算符(~)
   按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。例如, ~7的结果为0xfff8。
   取反运算常用来生成与系统实现无关的常数。如要将变量x最低6位置成0，其余位不变，可用代码x = x & ~077实现。以上代码与整数x用2个字节还是用4个字节实现无关。
   当两个长度不同的数据进行位运算时(例如long型数据与int型数据)，将两个运算分量的右端对齐进行位运算。如果短的数为正数，高位用0补满；如果短的数为负数，高位用1补满。如果短的为无符号整数，则高位总是用0补满。
   位运算用来对位串信息进行运算，得到位串信息结果。如以下代码能取下整型变量k的位串信息的最右边为1的信息位：((k-1)^k) & k。
   移位运算
   移位运算用来将整型或字符型数据作为二进位信息串作整体移动。有两个运算符：
   << (左移) 和 >> (右移)
   移位运算是双目运算，有两个运算分量,左分量为移位数据对象，右分量的值为移位位数。移位运算将左运算分量视作由二进位组成的位串信息,对其作向左或向右移位，得到新的位串信息。
   移位运算符的优先级低于算术运算符，高于关系运算符，它们的结合方向是自左至右。
   (1)左移运算符(<<)
   左移运算将一个位串信息向左移指定的位，右端空出的位用0补充。例如014<<2,结果为060,即48。
   左移时，空出的右端用0补充，左端移出的位的信息就被丢弃。在二进制数运算中，在信息没有因移动而丢失的情况下，每左移1位相当于乘2。如4 << 2，结果为16。
   (2)右移运算符(>>)
   右移运算将一个位串信息向右移指定的位，右端移出的位的信息被丢弃。例如12>>2,结果为3。与左移相反，对于小整数，每右移1位，相当于除以2。在右移时，需要注意符号位问题。对无符号数据，右移时，左端空出的位用0补充。对于带符号的数据，如果移位前符号位为0(正数)，则左端也是用0补充；如果移位前符号位为1(负数)，则左端用0或用1补充，取决于计算机系统。对于负数右移，称用0 补充的系统为“逻辑右移”，用1补充的系统为“算术右移”
 * */

void main() {
	uint8_t a1 = 0x03;
	uint8_t a2 = 0x05;
	uint8_t res = a1 & a2;
	printf("%02X\n", res);

	uint8_t res2 = a1 ^ a1;
	printf("%02X\n", res2);

	uint8_t b1 = 0xB3;
	uint8_t b2 = 0xCD;
	uint8_t res3 = b1 ^ b2;
	printf("res3 = b1 ^b2  = %X\n", res);
	uint8_t b3 = res3 ^ b1;
	printf("b3 = res3 ^b1  = %X\n", b3);
	uint8_t b4 = res3 ^ b2;
	printf("b4 = res3 ^b2  = %X\n", b4);
}
