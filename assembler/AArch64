AArch64 指令集汇编代码

指令的基本格式如下:
<Opcode>{<Cond>}<S><Rd>,<Rn> {<Opcode2>}
其中各个部分的含义为:
Opcode:         操作码,也就是助记符,说明指令需要执行的操作类型
Cond:           指令执行条件码
S:              条件码设置项,决定本次指令执行是否影响PSTATE寄存器相应状态位值
Rd/Xt:          目标寄存器,A64指令可以选择X0-X30
Rn/Xn:          第一个操作数的寄存器,和Rd一样,不同指令有不同要求
Opcode2:        第二个操作数,可以是立即数,寄存器Rm和寄存器移位方式(Rm,#shit)
MOV	把操作数赋值到寄存器里
例如:
mov x2, 0x3              # 把0x40值赋值给x2寄存器

1000 0000 0000 0010 0000 0011 0100 10
1100 0100 0000 0001 0000 0001 1010 010
1000 0010 0000 0000 1000 0000 1101 0010
1010 0010 0000 0000 1000 0000 1101 0010
1100 0010 0000 0000 1000 0000 1101 0010

1110 0010 0001 1111 1000 0000 1101 0010
1110 0000 1111 1111 1001 1111 1101 0010

28-31           位是条件码
21-24           为操作码
12-19           为寄存器编号

B/BL/BR/BLR 跳转指令
跳转分为绝对地址寻址跟相对地址寻址两种方式,B/BL 是相对地址寻址方式,目标地址是相对PC的偏移地址,两者都是无条件跳转,区别是BL会把下一条指令地址保存到LR(x30)寄存器里,
这样当子程序执行完了也能借助LR(x30)寄存器跳转回到主程序继续执行。与之对应的BR/BLR就是绝对地址寻址跳转,BLR跟BL性质一样,在跳转前会把下一条指令地址保存到LR(x30)寄存器里
例如:
mov x0, 0x400000   	# 把0x400000地址赋值给x0寄存器
br x0  				# 跳转到0x400000去

b 8 				# 跳转到PC+8的地方去执行


比较并跳转
BLT 				小于（有符号数）


STR  即store register,把寄存器的值保存到内存中
例如:
mov x2, 0x400000 	
str x5, [x2]		# 把x5寄存器的值保存到内存地址0x400000中
str x6, [x2, #8]	# 把x6寄存器的数据保存到0x400000+8的内存地址中


LDR  即load register,把数据从内存中加载到寄存器去
例如:
ldr x0, [x1] 		# 把x1寄存器所指向的内存数据加载到x0寄存器里
ldr x1, 0x8 		# 把将当前PC寄存器的地址 + 0x8偏移,取出地址内容填充到x1寄存器中


LDP/STP	 跟ldr/str指令相似的,区别是支持多字节(16 byte)操作
例如:
ldp x1, x2, [x0]  	# 把x0寄存器所指向的内存数据加载到x1寄存器里,把0x+0x8所指向的内存数据加载到x2寄存器里
stp x3, x4, [x5] 	# 把x3的数据存储到x5指向的内存中,把x4的数据存储到x5+0x8所指向的内存中


BRK	断点指令
例如:
brk 0x80  			# 产生 0x80中断


SVC 产生软中断,在Linux下系统调用是用软中断实现的,在使用软中断进行系统调时,系统调用号通过x8寄存器传递,用svc指令产生软中断,实现从用户模式到root模式的切换。
例如:
mov x0, 123 // exit code
mov x8, 93  // sys_exit() is at index 93 in kernel functions table
svc #0      // generate kernel call sys_exit(123);


ADR指令
这是一条小范围的地址读取指令,它将基于PC的相对偏移的地址读到目标寄存器中
使用格式:ADR register exper
编译时,首先会计算出当前PC到exper的偏移量#offset_to_exper
然后会用ADD或SUB指令,来替换这条指令例如ADD register,PC,#offset_to_exper
register就是exper的地址

ADRP指令
编译时,首先会计算出当前PC到exper的偏移量#offset_to_exper
pc的低12位清零,然后加上偏移量,给register
得到的地址,是含有label的4KB对齐内存区域的base地址

原理 adrp操作步骤adrp x0, 1
1.将1的值,左移12位 1 0000 0000 0000 == 0x1000
2.将PC寄存器的低12位清零 0x1045228b0  ==> 0x104522000
3.将1 和 2 的结果相加  给 X0 寄存器!!
注:地址为pc寄存器左边的地址,adrp是找出要获取参数的地址范围,然后下个pc寄存器执行的代码会定位到准确的物理地址。
指令区域
由于adrp的为范围寻址并不会精确到具体地址所以地址的最后三位,即12bit为0是需要系统下一步执行的时候补上的。
根据cpu总线的计算规则12bit相当于12根总线器地址范围为2的12次方即4KB


BIC
BIC指令的格式为: BIC{条件}{S}  目的寄存器,操作数1,操作数2
BIC指令用于清除操作数1的某些位,并把结果放置到目的寄存器中。
操作数1应是一个寄存器, 操作数2可以是一个寄存器、被移位的寄存器、或一个立即数。
操作数2为32位的掩码,如果在掩码中置了某一位1,则清除这一位。未设置的掩码位保持不变。
BIC  R0,R0,#0x1F
0x1F=0001 1111
含义:清除R0的bit[4:0]位。


ORR
ORR指令的格式为: ORR{条件}{S}  目的寄存器,操作数1,操作数2
ORR指令用于在两个操作数上进行逻辑或运算,并把结果放置到目的寄存器中。
操作数1应是一 个寄存器,操作数2可以是一个寄存器,被移位的寄存器,或一个立即数。
操作数2为32位的掩码,如果在掩码中置了某一位1,则将这一位置1。未设置的掩码位保持不变。
ORR R0,R0,#0xD3
0xD3=1101 0011
将r0与0xd3作算数或运算,然后将结果返还给r0,即把r0的bit[7:6]和bit[4]和bit[1:0]置为1。
