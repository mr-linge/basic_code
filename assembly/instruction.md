# AArch64 常用汇编指令

## 标签

在汇编语言中,标签往往不进行缩进,同时以:结尾。标签的作用是标记当前的地址

## 转移指令

mov     寄存器与寄存器或者寄存器与常量之间传值,指令中立即数范围为-65536~65535(17位),不能用于内存地址
mov x0,0x100            ;将立即数0x100 加载到 x0
mov x1,x0               ;将寄存器x0的值传送到寄存器x1

## 加载/存储指令

ldr     (load register)读取指令,将数据从内存中读取出来,存到寄存器中
ldr x0, [x1]       ;将x1寄存器对应内存处的数据加载到x0寄存器
ldr x1, 0x8       ;内存[pc + 0x8]数据填充到x1寄存器

str     (store register)写入指令,将数据从寄存器中读出来,写入到内存中
str x0, [sp, #0x8]      ;将寄存器 x0 中的值保存到栈内存 [sp + 0x8] 处

## 栈操作

16 字节对齐
stp/ldp 操作0x10字节
入栈
sub     sp,     sp,     #0x30
stp     x9,     x10,    [sp]
stp     x11,    x12,    [sp, #0x10]
stp     x13,    x14,    [sp, #0x20]
出栈
ldp     x9,     x10,    [sp]
ldp     x11,    x12,    [sp, #0x10]
ldp     x13,    x14,    [sp, #0x20]
add     sp,     sp,     #0x30

str/ldr 操作8字节
入栈
sub sp, sp, #0x10
str x0, [sp, #8]
str x1, [sp]
出栈
ldr x0, [sp, #8]
ldr x1, [sp]
add sp, sp, #0x10

## 判断

cmp <wn>, #<imm>        ;该指令中#<imm>为无符号立即数,取值范围为0~4095 (12 bit)

## 数据处理指令

add     两个数相加
add x0, x0, #1          ; 将寄存器 x0 的值和常量 1 相加后保存在寄存器 x0 中
add x0, x1, x2          ; 将寄存器 x1 和 x2 的值相加后保存到寄存器 x0 中
add x0, x1, [x2]        ; 将寄存器 x1 的值加上寄存器 x2 的值作为地址,再取该内存地址的内容放入寄存器 x0 中

sub     两个数相减
sub x0, x1, x2          ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中

MADD Rd, Rn, Rm, Ra
Rd = Ra + Rn * Rm

MSUB Rd, Rn, Rm, Ra  
Rd = Ra - Rn * Rm

## 跳转

相对地址寻址(目标地址是相对PC的偏移地址)
B       只跳转
BL      会把下一条指令地址保存到LR(x30)寄存器里,当子程序执行完了也能借助LR(x30)寄存器跳转回到主程序继续执行

最大寻址范围: 128m

例子
b 8                     ;跳转到PC+8的地方去执行

绝对地址寻址
BR      只跳转
BLR     会把下一条指令地址保存到LR(x30)寄存器里,当子程序执行完了也能借助LR(x30)寄存器跳转回到主程序继续执行

例子
mov x0, 0x400000        ;把0x400000地址赋值给x0寄存器
br x0                   ;跳转到0x400000去

函数返回
ret     将PC设置为LR寄存器的值

## 寻址

adr  Rn,  label
提供21位来编码 label 与 PC 的差值(当前PC的+/-1MB范围内的标签)

adrp  Rn, label
将 label 所在的页与PC所在的页的差值除以页大小后进行编码, Rn 存储的值是 label 所在的页的地址。
先计算 label 所在的页,再计算当前PC所在的页,两者相减,得到一个距离。而页大小是4KB,所以这个距离一定是4KB的倍数,从而可以放心地将其除以4KB。
这样的话,可以表示的距离范围,就是1MB再乘以4KB,也就是+/-4G

:lo12:label
取 label 低12位 即页内偏移offset

## svc 系统调用

在Linux下系统调用是用软中断实现的,在使用软中断进行系统调时,系统调用号通过x8寄存器传递,用svc指令产生软中断,实现从用户模式到root模式的切换。
SVC 指令会引发一个异常。处理器模式会更改为超级用户模式,CPSR 会保存到超级用户模式 SPSR,并且执行会跳转到 SVC 向量表.
例如:
    mov     x0, #0         // status := 0
    mov     w8, #93        // exit is syscall #93
    svc     #0             // invoke syscall
